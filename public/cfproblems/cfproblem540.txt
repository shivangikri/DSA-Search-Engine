This is an interactive problem.You are given two integers cc and nn. The jury has a randomly generated set AA of distinct positive integers not greater than cc (it is generated from all such possible sets with equal probability). The size of AA is equal to nn.Your task is to guess the set AA. In order to guess it, you can ask at most ⌈0.65⋅c⌉⌈0.65⋅c⌉ queries.In each query, you choose a single integer 1≤x≤c1≤x≤c. As the answer to this query you will be given the bitwise xor sum of all yy, such that y∈Ay∈A and gcd(x,y)=1gcd(x,y)=1 (i.e. xx and yy are coprime). If there is no such yy this xor sum is equal to 00.You can ask all queries at the beginning and you will receive the answers to all your queries. After that, you won't have the possibility to ask queries.You should find any set A′A′, such that |A′|=n|A′|=n and A′A′ and AA have the same answers for all cc possible queries.
InputFirstly you are given two integers cc and nn (100≤c≤106100≤c≤106, 0≤n≤c0≤n≤c).
InteractionIn the first line you should print an integer qq (0≤q≤⌈0.65⋅c⌉)(0≤q≤⌈0.65⋅c⌉) — the number of queries you want to ask. After that in the same line print qq integers x1,x2,…,xqx1,x2,…,xq (1≤xi≤c)(1≤xi≤c) — the queries.For these queries you should read qq integers, ii-th of them is the answer to the described query for x=xix=xi.After that you should print nn distinct integers A′1,A′2,…,A′nA1′,A2′,…,An′ — the set A′A′ you found.If there are different sets A′A′ that have the same answers for all possible queries, print any of them.If you will ask more than ⌈0.65⋅c⌉⌈0.65⋅c⌉ queries or if the queries will be invalid, the interactor will terminate immediately and your program will receive verdict Wrong Answer.After printing the queries and answers do not forget to output end of line and flush the output buffer. Otherwise, you will get the Idleness limit exceeded verdict. To do flush use:  fflush(stdout) or cout.flush() in C++;  System.out.flush() in Java;  flush(output) in Pascal;  stdout.flush() in Python;  Read documentation for other languages. HacksYou cannot make hacks in this problem.
ExampleInputCopy10 6

1 4 2 11 4 4 4

OutputCopy7 10 2 3 5 7 1 6

1 4 5 6 8 10

NoteThe sample is made only for you to understand the interaction protocol. Your solution will not be tested on the sample.In the sample A={1,4,5,6,8,10}A={1,4,5,6,8,10}. 77 queries are made, 7≤⌈0.65⋅10⌉=77≤⌈0.65⋅10⌉=7, so the query limit is not exceeded.Answers for the queries:   For 1010: 11 is the only number in the set AA coprime with 1010, so the answer is 11  For 22: 110⊕510=0012⊕1012=410110⊕510=0012⊕1012=410, where ⊕⊕ is the bitwise xor  For 33: 110⊕410⊕510⊕810⊕1010=00012⊕01002⊕01012⊕10002⊕10102=210110⊕410⊕510⊕810⊕1010=00012⊕01002⊕01012⊕10002⊕10102=210  For 55: 110⊕410⊕610⊕810=00012⊕01002⊕01102⊕10002=1110110⊕410⊕610⊕810=00012⊕01002⊕01102⊕10002=1110  For 77: 110⊕410⊕510⊕610⊕810⊕1010=00012⊕01002⊕01012⊕01102⊕10002⊕10102=410110⊕410⊕510⊕610⊕810⊕1010=00012⊕01002⊕01012⊕01102⊕10002⊕10102=410  For 11: 110⊕410⊕510⊕610⊕810⊕1010=00012⊕01002⊕01012⊕01102⊕10002⊕10102=410110⊕410⊕510⊕610⊕810⊕1010=00012⊕01002⊕01012⊕01102⊕10002⊕10102=410  For 66: 110⊕510=00012⊕01012=410110⊕510=00012⊕01012=410 