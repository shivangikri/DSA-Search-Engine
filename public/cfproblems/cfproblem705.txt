You are given a rooted tree. Each vertex contains aiai tons of gold, which costs cici per one ton. Initially, the tree consists only a root numbered 00 with a0a0 tons of gold and price c0c0 per ton.There are qq queries. Each query has one of two types:   Add vertex ii (where ii is an index of query) as a son to some vertex pipi; vertex ii will have aiai tons of gold with cici per ton. It's guaranteed that ci>cpici>cpi.  For a given vertex vivi consider the simple path from vivi to the root. We need to purchase wiwi tons of gold from vertices on this path, spending the minimum amount of money. If there isn't enough gold on the path, we buy all we can. If we buy xx tons of gold in some vertex vv the remaining amount of gold in it decreases by xx (of course, we can't buy more gold that vertex has at the moment). For each query of the second type, calculate the resulting amount of gold we bought and the amount of money we should spend.Note that you should solve the problem in online mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query, so don't forget to flush output after printing answers. You can use functions like fflush(stdout) in C++ and BufferedWriter.flush in Java or similar after each writing in your program. In standard (if you don't tweak I/O), endl flushes cout in C++ and System.out.println in Java (or println in Kotlin) makes automatic flush as well. 
InputThe first line contains three integers qq, a0a0 and c0c0 (1≤q≤3⋅1051≤q≤3⋅105; 1≤a0,c0<1061≤a0,c0<106) — the number of queries, the amount of gold in the root and its price.Next qq lines contain descriptions of queries; The ii-th query has one of two types:   "11 pipi aiai cici" (0≤pi<i0≤pi<i; 1≤ai,ci<1061≤ai,ci<106): add vertex ii as a son to vertex pipi. The vertex ii will have aiai tons of gold with price cici per one ton. It's guaranteed that pipi exists and ci>cpici>cpi. "22 vivi wiwi" (0≤vi<i0≤vi<i; 1≤wi<1061≤wi<106): buy wiwi tons of gold from vertices on path from vivi to 00 spending the minimum amount of money. If there isn't enough gold, we buy as much as we can. It's guaranteed that vertex vivi exist. It's guaranteed that there is at least one query of the second type.
OutputFor each query of the second type, print the resulting amount of gold we bought and the minimum amount of money we should spend.
ExampleInputCopy5 5 2
2 0 2
1 0 3 4
2 2 4
1 0 1 3
2 4 2
OutputCopy2 4
4 10
1 3

NoteExplanation of the sample:At the first query, the tree consist of root, so we purchase 22 tons of gold and pay 2⋅2=42⋅2=4. 33 tons remain in the root.At the second query, we add vertex 22 as a son of vertex 00. Vertex 22 now has 33 tons of gold with price 44 per one ton.At the third query, a path from 22 to 00 consists of only vertices 00 and 22 and since c0<c2c0<c2 we buy 33 remaining tons of gold in vertex 00 and 11 ton in vertex 22. So we bought 3+1=43+1=4 tons and paid 3⋅2+1⋅4=103⋅2+1⋅4=10. Now, in vertex 00 no gold left and 22 tons of gold remain in vertex 22.At the fourth query, we add vertex 44 as a son of vertex 00. Vertex 44 now has 11 ton of gold with price 33.At the fifth query, a path from 44 to 00 consists of only vertices 00 and 44. But since no gold left in vertex 00 and only 11 ton is in vertex 44, we buy 11 ton of gold in vertex 44 and spend 1⋅3=31⋅3=3. Now, in vertex 44 no gold left.